== 和===的区别
==：运算符称作相等，用来检测两个操作数是否相等，这里的相等定义的非常宽松，可以允许进行类型转换
===：用来检测两个操作数是否严格相等
1、对于string,number等基础类型，==和===是有区别的
不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等
同类型比较，直接进行“值”比较，两者结果一样
2、对于Array,Object等高级类型，==和===是没有区别的
3、基础类型与高级类型，==和===是有区别的
对于==，将高级转化为基础类型，进行“值”比较，因为类型不同，===结果为false

a占几个字节
不同编码方式1个英文字母占的字节是不同的：

1，ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。

2，UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节

3，Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节
字符就是几个字母，比如a和A都是一个字符。aa就是两个字符。
每个字节是由8位组成的。位是最小的单位了，叫做bit。
而字节呢，叫做byte。
所以，一个英文字母，无论大写和小写都是一个字符、一个字节，8位。
一个汉字是一个字符、两个字节，16位

什么是hash
> 散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。
散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，
重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。
散列值通常用一个短的随机字母和数字组成的字符串来代表。

链接：https://www.jianshu.com/p/28cc0f676488

常用的算法
https://blog.csdn.net/u013270347/article/details/80604690

如何从大量数据中查找id对应的昵称
select * from 表名 where id='你要查询的id值'。
散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。
也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
这个映射函数叫做散列函数，存放记录的数组叫做散列表。

png格式图片和jpg格式图片有什么区别？
1、png即可移植网络图形格式，也是一种位图文件存储格式，可以进行无损压缩。而jpg是最常见的图片格式了
2、png占内存多，jpg占内存少
3、png可无损压缩，jpg则牺牲了图片质量
4、在ps中png可为透明背景，而jpg显然是不行的。
png是一种无损压缩的位图片形格式。其设计目的是为了替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。
png格式是非失真性压缩的，允许使用类似于GIF格式的调色板技术，支持真彩色图像，并具备阿尔法通道（半透明）等特性。
png使用从LZ77派生的无损数据压缩算法，由于它压缩比高，生成文件体积小？
这种特性可使在通信链路上传输图像文件的同时就在终端上显示图像，把整个轮廓显示出来之后逐步显示图像的细节，
也就是先用低分辨率显示图像，然后逐步提高它的分辨率。

OpenGL是什么？
OpenGL（英语：Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近350个不同的函数调用组成，用来绘制从简单的图形比特到复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。
OpenGL的高效实现（利用了图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。开放源代码库Mesa是一个纯基于软件的图形API，它的代码兼容于OpenGL。但是，由于许可证的原因，它只声称是一个“非常相似”的API。


cocos2dx内存管理机制
cocos2dx基于引用计数管理内存,所有继承自CCObject的对象都将获得引用计数的能力,可通过调用retain成员函数用于引用计数值,调用release减少引用计数值，当计数值减为0时销毁对象.
在程序中重载malloc 、free、new、delete
void* MyMalloc()
{
 printf("malloc");
 return malloc();
}
void MyFree(void*　fp)
{
 printf("free");
 free(fp);
}
